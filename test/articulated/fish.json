{"scene":{"name":"","type":"Scene","position":[0,0,0],"rotation":[0,0,0],"scale":[1,1,1],"children":[{"uniforms":{"lightColor":["Color",[1,1,1,1]]},"color":[1,1,1,1],"target":null,"direction":[0,0,0],"type":"DirectionalLight"},{"name":"","type":"ArticulatedModel","position":[0,0,0],"rotation":[0,0,0],"scale":[40,40,40],"children":[{"name":"RBody","type":"Rig","position":[0,0,0],"rotation":[0,0,0],"scale":[1,1,1],"children":[{"name":"PBody","type":"Mesh","position":[-1,0.2,-0.363],"rotation":[0,0,0],"scale":[0.66,0.9,1.41],"children":[],"geometry":{"type":"BoxGeometry","attributes":{},"width":1,"height":1,"depth":1,"position":{"x":0,"y":0,"z":0}}},{"name":"RTopHead","type":"Rig","position":[-1,0.43,0.71],"rotation":[0,0,0],"scale":[1,1,1],"children":[{"name":"PTopHead","type":"Mesh","position":[0,0,0],"rotation":[0,0,0],"scale":[1,0.53,1],"children":[],"geometry":{"type":"BoxGeometry","attributes":{},"width":1,"height":1,"depth":1,"position":{"x":0,"y":0,"z":0}}}],"id":"TopHead"},{"name":"RBottomHead","type":"Rig","position":[-1,-0.22,0.51],"rotation":[0,0,0],"scale":[1,1,1],"children":[{"name":"PBottomHead","type":"Mesh","position":[0,0,0],"rotation":[1,0,0],"scale":[1,0.14,0.47],"children":[],"geometry":{"type":"BoxGeometry","attributes":{},"width":1,"height":1,"depth":1,"position":{"x":0,"y":0,"z":0}}}],"id":"BottomHead"},{"name":"RPreTail","type":"Rig","position":[-1,0.2,-1.2],"rotation":[0,0,0],"scale":[1,1,1],"children":[{"name":"PPreTail","type":"Mesh","position":[0,0,0],"rotation":[0,0,0],"scale":[0.29,0.41,0.42],"children":[],"geometry":{"type":"BoxGeometry","attributes":{},"width":1,"height":1,"depth":1,"position":{"x":0,"y":0,"z":0}}},{"name":"RTail","type":"Rig","position":[0,0,-0.4],"rotation":[0,0,0],"scale":[1,1,1],"children":[{"name":"PTail","type":"Mesh","position":[0,0,0],"rotation":[0,0,0],"scale":[0.19,0.68,0.63],"children":[],"geometry":{"type":"BoxGeometry","attributes":{},"width":1,"height":1,"depth":1,"position":{"x":0,"y":0,"z":0}}}],"id":"Tail"}],"id":"PreTail"},{"name":"RRightFin","type":"Rig","position":[-0.4,-0.026,-0.143],"rotation":[0,0,0],"scale":[1,1,1],"children":[{"name":"PRightFin","type":"Mesh","position":[0,0,0],"rotation":[0,0,-22.93],"scale":[0.81,0.14,0.41],"children":[],"geometry":{"type":"BoxGeometry","attributes":{},"width":1,"height":1,"depth":1,"position":{"x":0,"y":0,"z":0}}}],"id":"RightFin"},{"name":"RLeftFin","type":"Rig","position":[-1.6,-0.026,-0.143],"rotation":[0,0,0],"scale":[1,1,1],"children":[{"name":"PLeftFin","type":"Mesh","position":[0,0,0],"rotation":[0,0,22.93],"scale":[0.81,0.14,0.41],"children":[],"geometry":{"type":"BoxGeometry","attributes":{},"width":1,"height":1,"depth":1,"position":{"x":0,"y":0,"z":0}}}],"id":"LeftFin"},{"name":"RTopFin","type":"Rig","position":[-1,0.75,-0.413],"rotation":[0,0,0],"scale":[1,1,1],"children":[{"name":"PTopFin","type":"Mesh","position":[0,0,0],"rotation":[0,0,0],"scale":[0.04,0.33,0.64],"children":[],"geometry":{"type":"BoxGeometry","attributes":{},"width":1,"height":1,"depth":1,"position":{"x":0,"y":0,"z":0}}}],"id":"TopFin"}],"id":"Body"}],"rigs":["Body","TopHead","BottomHead","PreTail","Tail","RightFin","LeftFin","TopFin"],"materials":{"PBody":[{"vertexShader":"\n        attribute vec4 position;\n        attribute vec4 color;\n        attribute vec3 normal;\n        attribute vec2 texcoord;\n        uniform bool u_useVertexColors;\n\n        uniform float u_shininess;\n        uniform vec3 u_lightDirection;\n        uniform vec3 u_cameraPosition;\n\n        uniform vec4 u_ambientColor;\n        uniform vec4 u_diffuseColor;\n        uniform vec4 u_specularColor;\n        varying vec4 v_color;\n\n        uniform mat4 u_worldMatrix;\n        uniform mat4 u_viewMatrix;\n\n        uniform sampler2D u_displacementMap;\n        uniform float u_displacementFactor;\n\n        varying vec3 v_lightDirection;\n        varying vec3 v_cameraPosition;\n        varying vec3 v_vertexPosition;\n        varying vec2 v_texcoord;\n        varying vec3 v_normal;\n\n        void main() {\n          gl_Position = u_viewMatrix * u_worldMatrix * position;\n          v_vertexPosition = gl_Position.xyz / gl_Position.w;\n          v_normal = mat3(u_worldMatrix) * normal;\n          v_color = color;\n          v_lightDirection = u_lightDirection;\n          v_cameraPosition = u_cameraPosition;\n          v_texcoord = texcoord;\n        }\n        ","fragmentShader":"\n      precision highp float;\n\n      uniform sampler2D u_normalMap;\n      uniform bool u_useNormalMap;\n      uniform vec4 u_ambientColor;\n      uniform vec4 u_lightColor;\n      uniform sampler2D u_diffuseMap;\n      uniform bool u_useDiffuseMap;\n      uniform vec4 u_diffuseColor;\n      uniform sampler2D u_specularMap;\n      uniform bool u_useSpecularMap;\n      uniform vec4 u_specularColor;\n      uniform float u_shininess;\n      uniform bool u_useVertexColors;\n      uniform bool u_useEnvironmentMapping;\n      uniform bool u_useTextureMapping;\n      uniform samplerCube u_environmentMap;\n\n      varying vec3 v_lightDirection;\n      varying vec3 v_cameraPosition;\n      varying vec3 v_vertexPosition;\n      varying vec2 v_texcoord;\n      varying vec3 v_normal;\n      varying vec4 v_color;\n\n      void main() {\n          vec3 L = -normalize(v_lightDirection - v_vertexPosition);\n          vec3 V = normalize(v_cameraPosition);\n          vec3 H = normalize(L + V);\n          vec3 N;\n          vec4 diffuse;\n          vec4 specular;\n\n          if (u_useNormalMap && u_useTextureMapping) {\n              N = texture2D(u_normalMap, v_texcoord).rgb;\n              N = normalize(N * 2.0 - 1.0);\n          } else {\n              N = normalize(v_normal);\n          }\n\n          vec3 direction = reflect(normalize(v_vertexPosition - v_cameraPosition), N);\n          vec4 ambient = u_ambientColor * u_lightColor * 0.3;\n\n          if (u_useDiffuseMap && u_useTextureMapping) {\n            diffuse =\n              u_diffuseColor *\n              max(dot(L, N), 0.0) *\n              texture2D(u_diffuseMap, v_texcoord);\n          } else {\n            diffuse =\n              u_diffuseColor *\n              max(dot(L, N), 0.0);\n          }\n\n          if (u_useSpecularMap && u_useTextureMapping) {\n            specular = u_specularColor *\n              pow(max(dot(N, H), 0.0), u_shininess) *\n              texture2D(u_specularMap, v_texcoord);\n          } else {\n            specular = u_specularColor *\n              pow(max(dot(N, H), 0.0), u_shininess);\n          }\n\n          float attenuation = 1.0;\n\n          if (u_useEnvironmentMapping) {\n            gl_FragColor = textureCube(u_environmentMap, direction);\n          } else {\n            gl_FragColor = attenuation * (diffuse + specular) + ambient;\n          }\n\n          if (u_useVertexColors) {\n            gl_FragColor = gl_FragColor * v_color;\n          }\n      }\n    ","uniforms":{"ambientColor":["Color",[0,0,0,0.5]],"diffuseColor":["Color",[1,1,1,1]],"specularColor":["Color",[1,1,1,1]],"shininess":1},"type":"PhongMaterial","name":"PhongP"}],"PTopHead":[{"vertexShader":"\n        attribute vec4 position;\n        attribute vec4 color;\n        attribute vec3 normal;\n        attribute vec2 texcoord;\n        uniform bool u_useVertexColors;\n\n        uniform float u_shininess;\n        uniform vec3 u_lightDirection;\n        uniform vec3 u_cameraPosition;\n\n        uniform vec4 u_ambientColor;\n        uniform vec4 u_diffuseColor;\n        uniform vec4 u_specularColor;\n        varying vec4 v_color;\n\n        uniform mat4 u_worldMatrix;\n        uniform mat4 u_viewMatrix;\n\n        uniform sampler2D u_displacementMap;\n        uniform float u_displacementFactor;\n\n        varying vec3 v_lightDirection;\n        varying vec3 v_cameraPosition;\n        varying vec3 v_vertexPosition;\n        varying vec2 v_texcoord;\n        varying vec3 v_normal;\n\n        void main() {\n          gl_Position = u_viewMatrix * u_worldMatrix * position;\n          v_vertexPosition = gl_Position.xyz / gl_Position.w;\n          v_normal = mat3(u_worldMatrix) * normal;\n          v_color = color;\n          v_lightDirection = u_lightDirection;\n          v_cameraPosition = u_cameraPosition;\n          v_texcoord = texcoord;\n        }\n        ","fragmentShader":"\n      precision highp float;\n\n      uniform sampler2D u_normalMap;\n      uniform bool u_useNormalMap;\n      uniform vec4 u_ambientColor;\n      uniform vec4 u_lightColor;\n      uniform sampler2D u_diffuseMap;\n      uniform bool u_useDiffuseMap;\n      uniform vec4 u_diffuseColor;\n      uniform sampler2D u_specularMap;\n      uniform bool u_useSpecularMap;\n      uniform vec4 u_specularColor;\n      uniform float u_shininess;\n      uniform bool u_useVertexColors;\n      uniform bool u_useEnvironmentMapping;\n      uniform bool u_useTextureMapping;\n      uniform samplerCube u_environmentMap;\n\n      varying vec3 v_lightDirection;\n      varying vec3 v_cameraPosition;\n      varying vec3 v_vertexPosition;\n      varying vec2 v_texcoord;\n      varying vec3 v_normal;\n      varying vec4 v_color;\n\n      void main() {\n          vec3 L = -normalize(v_lightDirection - v_vertexPosition);\n          vec3 V = normalize(v_cameraPosition);\n          vec3 H = normalize(L + V);\n          vec3 N;\n          vec4 diffuse;\n          vec4 specular;\n\n          if (u_useNormalMap && u_useTextureMapping) {\n              N = texture2D(u_normalMap, v_texcoord).rgb;\n              N = normalize(N * 2.0 - 1.0);\n          } else {\n              N = normalize(v_normal);\n          }\n\n          vec3 direction = reflect(normalize(v_vertexPosition - v_cameraPosition), N);\n          vec4 ambient = u_ambientColor * u_lightColor * 0.3;\n\n          if (u_useDiffuseMap && u_useTextureMapping) {\n            diffuse =\n              u_diffuseColor *\n              max(dot(L, N), 0.0) *\n              texture2D(u_diffuseMap, v_texcoord);\n          } else {\n            diffuse =\n              u_diffuseColor *\n              max(dot(L, N), 0.0);\n          }\n\n          if (u_useSpecularMap && u_useTextureMapping) {\n            specular = u_specularColor *\n              pow(max(dot(N, H), 0.0), u_shininess) *\n              texture2D(u_specularMap, v_texcoord);\n          } else {\n            specular = u_specularColor *\n              pow(max(dot(N, H), 0.0), u_shininess);\n          }\n\n          float attenuation = 1.0;\n\n          if (u_useEnvironmentMapping) {\n            gl_FragColor = textureCube(u_environmentMap, direction);\n          } else {\n            gl_FragColor = attenuation * (diffuse + specular) + ambient;\n          }\n\n          if (u_useVertexColors) {\n            gl_FragColor = gl_FragColor * v_color;\n          }\n      }\n    ","uniforms":{"ambientColor":["Color",[0,0,0,0.5]],"diffuseColor":["Color",[1,1,1,1]],"specularColor":["Color",[1,1,1,1]],"shininess":1},"type":"PhongMaterial","name":"PhongP"}],"PBottomHead":[{"vertexShader":"\n        attribute vec4 position;\n        attribute vec4 color;\n        attribute vec3 normal;\n        attribute vec2 texcoord;\n        uniform bool u_useVertexColors;\n\n        uniform float u_shininess;\n        uniform vec3 u_lightDirection;\n        uniform vec3 u_cameraPosition;\n\n        uniform vec4 u_ambientColor;\n        uniform vec4 u_diffuseColor;\n        uniform vec4 u_specularColor;\n        varying vec4 v_color;\n\n        uniform mat4 u_worldMatrix;\n        uniform mat4 u_viewMatrix;\n\n        uniform sampler2D u_displacementMap;\n        uniform float u_displacementFactor;\n\n        varying vec3 v_lightDirection;\n        varying vec3 v_cameraPosition;\n        varying vec3 v_vertexPosition;\n        varying vec2 v_texcoord;\n        varying vec3 v_normal;\n\n        void main() {\n          gl_Position = u_viewMatrix * u_worldMatrix * position;\n          v_vertexPosition = gl_Position.xyz / gl_Position.w;\n          v_normal = mat3(u_worldMatrix) * normal;\n          v_color = color;\n          v_lightDirection = u_lightDirection;\n          v_cameraPosition = u_cameraPosition;\n          v_texcoord = texcoord;\n        }\n        ","fragmentShader":"\n      precision highp float;\n\n      uniform sampler2D u_normalMap;\n      uniform bool u_useNormalMap;\n      uniform vec4 u_ambientColor;\n      uniform vec4 u_lightColor;\n      uniform sampler2D u_diffuseMap;\n      uniform bool u_useDiffuseMap;\n      uniform vec4 u_diffuseColor;\n      uniform sampler2D u_specularMap;\n      uniform bool u_useSpecularMap;\n      uniform vec4 u_specularColor;\n      uniform float u_shininess;\n      uniform bool u_useVertexColors;\n      uniform bool u_useEnvironmentMapping;\n      uniform bool u_useTextureMapping;\n      uniform samplerCube u_environmentMap;\n\n      varying vec3 v_lightDirection;\n      varying vec3 v_cameraPosition;\n      varying vec3 v_vertexPosition;\n      varying vec2 v_texcoord;\n      varying vec3 v_normal;\n      varying vec4 v_color;\n\n      void main() {\n          vec3 L = -normalize(v_lightDirection - v_vertexPosition);\n          vec3 V = normalize(v_cameraPosition);\n          vec3 H = normalize(L + V);\n          vec3 N;\n          vec4 diffuse;\n          vec4 specular;\n\n          if (u_useNormalMap && u_useTextureMapping) {\n              N = texture2D(u_normalMap, v_texcoord).rgb;\n              N = normalize(N * 2.0 - 1.0);\n          } else {\n              N = normalize(v_normal);\n          }\n\n          vec3 direction = reflect(normalize(v_vertexPosition - v_cameraPosition), N);\n          vec4 ambient = u_ambientColor * u_lightColor * 0.3;\n\n          if (u_useDiffuseMap && u_useTextureMapping) {\n            diffuse =\n              u_diffuseColor *\n              max(dot(L, N), 0.0) *\n              texture2D(u_diffuseMap, v_texcoord);\n          } else {\n            diffuse =\n              u_diffuseColor *\n              max(dot(L, N), 0.0);\n          }\n\n          if (u_useSpecularMap && u_useTextureMapping) {\n            specular = u_specularColor *\n              pow(max(dot(N, H), 0.0), u_shininess) *\n              texture2D(u_specularMap, v_texcoord);\n          } else {\n            specular = u_specularColor *\n              pow(max(dot(N, H), 0.0), u_shininess);\n          }\n\n          float attenuation = 1.0;\n\n          if (u_useEnvironmentMapping) {\n            gl_FragColor = textureCube(u_environmentMap, direction);\n          } else {\n            gl_FragColor = attenuation * (diffuse + specular) + ambient;\n          }\n\n          if (u_useVertexColors) {\n            gl_FragColor = gl_FragColor * v_color;\n          }\n      }\n    ","uniforms":{"ambientColor":["Color",[0,0,0,0.5]],"diffuseColor":["Color",[1,1,1,1]],"specularColor":["Color",[1,1,1,1]],"shininess":1},"type":"PhongMaterial","name":"PhongP"}],"PPreTail":[{"vertexShader":"\n        attribute vec4 position;\n        attribute vec4 color;\n        attribute vec3 normal;\n        attribute vec2 texcoord;\n        uniform bool u_useVertexColors;\n\n        uniform float u_shininess;\n        uniform vec3 u_lightDirection;\n        uniform vec3 u_cameraPosition;\n\n        uniform vec4 u_ambientColor;\n        uniform vec4 u_diffuseColor;\n        uniform vec4 u_specularColor;\n        varying vec4 v_color;\n\n        uniform mat4 u_worldMatrix;\n        uniform mat4 u_viewMatrix;\n\n        uniform sampler2D u_displacementMap;\n        uniform float u_displacementFactor;\n\n        varying vec3 v_lightDirection;\n        varying vec3 v_cameraPosition;\n        varying vec3 v_vertexPosition;\n        varying vec2 v_texcoord;\n        varying vec3 v_normal;\n\n        void main() {\n          gl_Position = u_viewMatrix * u_worldMatrix * position;\n          v_vertexPosition = gl_Position.xyz / gl_Position.w;\n          v_normal = mat3(u_worldMatrix) * normal;\n          v_color = color;\n          v_lightDirection = u_lightDirection;\n          v_cameraPosition = u_cameraPosition;\n          v_texcoord = texcoord;\n        }\n        ","fragmentShader":"\n      precision highp float;\n\n      uniform sampler2D u_normalMap;\n      uniform bool u_useNormalMap;\n      uniform vec4 u_ambientColor;\n      uniform vec4 u_lightColor;\n      uniform sampler2D u_diffuseMap;\n      uniform bool u_useDiffuseMap;\n      uniform vec4 u_diffuseColor;\n      uniform sampler2D u_specularMap;\n      uniform bool u_useSpecularMap;\n      uniform vec4 u_specularColor;\n      uniform float u_shininess;\n      uniform bool u_useVertexColors;\n      uniform bool u_useEnvironmentMapping;\n      uniform bool u_useTextureMapping;\n      uniform samplerCube u_environmentMap;\n\n      varying vec3 v_lightDirection;\n      varying vec3 v_cameraPosition;\n      varying vec3 v_vertexPosition;\n      varying vec2 v_texcoord;\n      varying vec3 v_normal;\n      varying vec4 v_color;\n\n      void main() {\n          vec3 L = -normalize(v_lightDirection - v_vertexPosition);\n          vec3 V = normalize(v_cameraPosition);\n          vec3 H = normalize(L + V);\n          vec3 N;\n          vec4 diffuse;\n          vec4 specular;\n\n          if (u_useNormalMap && u_useTextureMapping) {\n              N = texture2D(u_normalMap, v_texcoord).rgb;\n              N = normalize(N * 2.0 - 1.0);\n          } else {\n              N = normalize(v_normal);\n          }\n\n          vec3 direction = reflect(normalize(v_vertexPosition - v_cameraPosition), N);\n          vec4 ambient = u_ambientColor * u_lightColor * 0.3;\n\n          if (u_useDiffuseMap && u_useTextureMapping) {\n            diffuse =\n              u_diffuseColor *\n              max(dot(L, N), 0.0) *\n              texture2D(u_diffuseMap, v_texcoord);\n          } else {\n            diffuse =\n              u_diffuseColor *\n              max(dot(L, N), 0.0);\n          }\n\n          if (u_useSpecularMap && u_useTextureMapping) {\n            specular = u_specularColor *\n              pow(max(dot(N, H), 0.0), u_shininess) *\n              texture2D(u_specularMap, v_texcoord);\n          } else {\n            specular = u_specularColor *\n              pow(max(dot(N, H), 0.0), u_shininess);\n          }\n\n          float attenuation = 1.0;\n\n          if (u_useEnvironmentMapping) {\n            gl_FragColor = textureCube(u_environmentMap, direction);\n          } else {\n            gl_FragColor = attenuation * (diffuse + specular) + ambient;\n          }\n\n          if (u_useVertexColors) {\n            gl_FragColor = gl_FragColor * v_color;\n          }\n      }\n    ","uniforms":{"ambientColor":["Color",[0,0,0,0.5]],"diffuseColor":["Color",[1,1,1,1]],"specularColor":["Color",[1,1,1,1]],"shininess":1},"type":"PhongMaterial","name":"PhongP"}],"PTail":[{"vertexShader":"\n        attribute vec4 position;\n        attribute vec4 color;\n        attribute vec3 normal;\n        attribute vec2 texcoord;\n        uniform bool u_useVertexColors;\n\n        uniform float u_shininess;\n        uniform vec3 u_lightDirection;\n        uniform vec3 u_cameraPosition;\n\n        uniform vec4 u_ambientColor;\n        uniform vec4 u_diffuseColor;\n        uniform vec4 u_specularColor;\n        varying vec4 v_color;\n\n        uniform mat4 u_worldMatrix;\n        uniform mat4 u_viewMatrix;\n\n        uniform sampler2D u_displacementMap;\n        uniform float u_displacementFactor;\n\n        varying vec3 v_lightDirection;\n        varying vec3 v_cameraPosition;\n        varying vec3 v_vertexPosition;\n        varying vec2 v_texcoord;\n        varying vec3 v_normal;\n\n        void main() {\n          gl_Position = u_viewMatrix * u_worldMatrix * position;\n          v_vertexPosition = gl_Position.xyz / gl_Position.w;\n          v_normal = mat3(u_worldMatrix) * normal;\n          v_color = color;\n          v_lightDirection = u_lightDirection;\n          v_cameraPosition = u_cameraPosition;\n          v_texcoord = texcoord;\n        }\n        ","fragmentShader":"\n      precision highp float;\n\n      uniform sampler2D u_normalMap;\n      uniform bool u_useNormalMap;\n      uniform vec4 u_ambientColor;\n      uniform vec4 u_lightColor;\n      uniform sampler2D u_diffuseMap;\n      uniform bool u_useDiffuseMap;\n      uniform vec4 u_diffuseColor;\n      uniform sampler2D u_specularMap;\n      uniform bool u_useSpecularMap;\n      uniform vec4 u_specularColor;\n      uniform float u_shininess;\n      uniform bool u_useVertexColors;\n      uniform bool u_useEnvironmentMapping;\n      uniform bool u_useTextureMapping;\n      uniform samplerCube u_environmentMap;\n\n      varying vec3 v_lightDirection;\n      varying vec3 v_cameraPosition;\n      varying vec3 v_vertexPosition;\n      varying vec2 v_texcoord;\n      varying vec3 v_normal;\n      varying vec4 v_color;\n\n      void main() {\n          vec3 L = -normalize(v_lightDirection - v_vertexPosition);\n          vec3 V = normalize(v_cameraPosition);\n          vec3 H = normalize(L + V);\n          vec3 N;\n          vec4 diffuse;\n          vec4 specular;\n\n          if (u_useNormalMap && u_useTextureMapping) {\n              N = texture2D(u_normalMap, v_texcoord).rgb;\n              N = normalize(N * 2.0 - 1.0);\n          } else {\n              N = normalize(v_normal);\n          }\n\n          vec3 direction = reflect(normalize(v_vertexPosition - v_cameraPosition), N);\n          vec4 ambient = u_ambientColor * u_lightColor * 0.3;\n\n          if (u_useDiffuseMap && u_useTextureMapping) {\n            diffuse =\n              u_diffuseColor *\n              max(dot(L, N), 0.0) *\n              texture2D(u_diffuseMap, v_texcoord);\n          } else {\n            diffuse =\n              u_diffuseColor *\n              max(dot(L, N), 0.0);\n          }\n\n          if (u_useSpecularMap && u_useTextureMapping) {\n            specular = u_specularColor *\n              pow(max(dot(N, H), 0.0), u_shininess) *\n              texture2D(u_specularMap, v_texcoord);\n          } else {\n            specular = u_specularColor *\n              pow(max(dot(N, H), 0.0), u_shininess);\n          }\n\n          float attenuation = 1.0;\n\n          if (u_useEnvironmentMapping) {\n            gl_FragColor = textureCube(u_environmentMap, direction);\n          } else {\n            gl_FragColor = attenuation * (diffuse + specular) + ambient;\n          }\n\n          if (u_useVertexColors) {\n            gl_FragColor = gl_FragColor * v_color;\n          }\n      }\n    ","uniforms":{"ambientColor":["Color",[0,0,0,0.5]],"diffuseColor":["Color",[1,1,1,1]],"specularColor":["Color",[1,1,1,1]],"shininess":1},"type":"PhongMaterial","name":"PhongP"}],"PRightFin":[{"vertexShader":"\n        attribute vec4 position;\n        attribute vec4 color;\n        attribute vec3 normal;\n        attribute vec2 texcoord;\n        uniform bool u_useVertexColors;\n\n        uniform float u_shininess;\n        uniform vec3 u_lightDirection;\n        uniform vec3 u_cameraPosition;\n\n        uniform vec4 u_ambientColor;\n        uniform vec4 u_diffuseColor;\n        uniform vec4 u_specularColor;\n        varying vec4 v_color;\n\n        uniform mat4 u_worldMatrix;\n        uniform mat4 u_viewMatrix;\n\n        uniform sampler2D u_displacementMap;\n        uniform float u_displacementFactor;\n\n        varying vec3 v_lightDirection;\n        varying vec3 v_cameraPosition;\n        varying vec3 v_vertexPosition;\n        varying vec2 v_texcoord;\n        varying vec3 v_normal;\n\n        void main() {\n          gl_Position = u_viewMatrix * u_worldMatrix * position;\n          v_vertexPosition = gl_Position.xyz / gl_Position.w;\n          v_normal = mat3(u_worldMatrix) * normal;\n          v_color = color;\n          v_lightDirection = u_lightDirection;\n          v_cameraPosition = u_cameraPosition;\n          v_texcoord = texcoord;\n        }\n        ","fragmentShader":"\n      precision highp float;\n\n      uniform sampler2D u_normalMap;\n      uniform bool u_useNormalMap;\n      uniform vec4 u_ambientColor;\n      uniform vec4 u_lightColor;\n      uniform sampler2D u_diffuseMap;\n      uniform bool u_useDiffuseMap;\n      uniform vec4 u_diffuseColor;\n      uniform sampler2D u_specularMap;\n      uniform bool u_useSpecularMap;\n      uniform vec4 u_specularColor;\n      uniform float u_shininess;\n      uniform bool u_useVertexColors;\n      uniform bool u_useEnvironmentMapping;\n      uniform bool u_useTextureMapping;\n      uniform samplerCube u_environmentMap;\n\n      varying vec3 v_lightDirection;\n      varying vec3 v_cameraPosition;\n      varying vec3 v_vertexPosition;\n      varying vec2 v_texcoord;\n      varying vec3 v_normal;\n      varying vec4 v_color;\n\n      void main() {\n          vec3 L = -normalize(v_lightDirection - v_vertexPosition);\n          vec3 V = normalize(v_cameraPosition);\n          vec3 H = normalize(L + V);\n          vec3 N;\n          vec4 diffuse;\n          vec4 specular;\n\n          if (u_useNormalMap && u_useTextureMapping) {\n              N = texture2D(u_normalMap, v_texcoord).rgb;\n              N = normalize(N * 2.0 - 1.0);\n          } else {\n              N = normalize(v_normal);\n          }\n\n          vec3 direction = reflect(normalize(v_vertexPosition - v_cameraPosition), N);\n          vec4 ambient = u_ambientColor * u_lightColor * 0.3;\n\n          if (u_useDiffuseMap && u_useTextureMapping) {\n            diffuse =\n              u_diffuseColor *\n              max(dot(L, N), 0.0) *\n              texture2D(u_diffuseMap, v_texcoord);\n          } else {\n            diffuse =\n              u_diffuseColor *\n              max(dot(L, N), 0.0);\n          }\n\n          if (u_useSpecularMap && u_useTextureMapping) {\n            specular = u_specularColor *\n              pow(max(dot(N, H), 0.0), u_shininess) *\n              texture2D(u_specularMap, v_texcoord);\n          } else {\n            specular = u_specularColor *\n              pow(max(dot(N, H), 0.0), u_shininess);\n          }\n\n          float attenuation = 1.0;\n\n          if (u_useEnvironmentMapping) {\n            gl_FragColor = textureCube(u_environmentMap, direction);\n          } else {\n            gl_FragColor = attenuation * (diffuse + specular) + ambient;\n          }\n\n          if (u_useVertexColors) {\n            gl_FragColor = gl_FragColor * v_color;\n          }\n      }\n    ","uniforms":{"ambientColor":["Color",[0,0,0,0.5]],"diffuseColor":["Color",[1,1,1,1]],"specularColor":["Color",[1,1,1,1]],"shininess":1},"type":"PhongMaterial","name":"PhongP"}],"PLeftFin":[{"vertexShader":"\n        attribute vec4 position;\n        attribute vec4 color;\n        attribute vec3 normal;\n        attribute vec2 texcoord;\n        uniform bool u_useVertexColors;\n\n        uniform float u_shininess;\n        uniform vec3 u_lightDirection;\n        uniform vec3 u_cameraPosition;\n\n        uniform vec4 u_ambientColor;\n        uniform vec4 u_diffuseColor;\n        uniform vec4 u_specularColor;\n        varying vec4 v_color;\n\n        uniform mat4 u_worldMatrix;\n        uniform mat4 u_viewMatrix;\n\n        uniform sampler2D u_displacementMap;\n        uniform float u_displacementFactor;\n\n        varying vec3 v_lightDirection;\n        varying vec3 v_cameraPosition;\n        varying vec3 v_vertexPosition;\n        varying vec2 v_texcoord;\n        varying vec3 v_normal;\n\n        void main() {\n          gl_Position = u_viewMatrix * u_worldMatrix * position;\n          v_vertexPosition = gl_Position.xyz / gl_Position.w;\n          v_normal = mat3(u_worldMatrix) * normal;\n          v_color = color;\n          v_lightDirection = u_lightDirection;\n          v_cameraPosition = u_cameraPosition;\n          v_texcoord = texcoord;\n        }\n        ","fragmentShader":"\n      precision highp float;\n\n      uniform sampler2D u_normalMap;\n      uniform bool u_useNormalMap;\n      uniform vec4 u_ambientColor;\n      uniform vec4 u_lightColor;\n      uniform sampler2D u_diffuseMap;\n      uniform bool u_useDiffuseMap;\n      uniform vec4 u_diffuseColor;\n      uniform sampler2D u_specularMap;\n      uniform bool u_useSpecularMap;\n      uniform vec4 u_specularColor;\n      uniform float u_shininess;\n      uniform bool u_useVertexColors;\n      uniform bool u_useEnvironmentMapping;\n      uniform bool u_useTextureMapping;\n      uniform samplerCube u_environmentMap;\n\n      varying vec3 v_lightDirection;\n      varying vec3 v_cameraPosition;\n      varying vec3 v_vertexPosition;\n      varying vec2 v_texcoord;\n      varying vec3 v_normal;\n      varying vec4 v_color;\n\n      void main() {\n          vec3 L = -normalize(v_lightDirection - v_vertexPosition);\n          vec3 V = normalize(v_cameraPosition);\n          vec3 H = normalize(L + V);\n          vec3 N;\n          vec4 diffuse;\n          vec4 specular;\n\n          if (u_useNormalMap && u_useTextureMapping) {\n              N = texture2D(u_normalMap, v_texcoord).rgb;\n              N = normalize(N * 2.0 - 1.0);\n          } else {\n              N = normalize(v_normal);\n          }\n\n          vec3 direction = reflect(normalize(v_vertexPosition - v_cameraPosition), N);\n          vec4 ambient = u_ambientColor * u_lightColor * 0.3;\n\n          if (u_useDiffuseMap && u_useTextureMapping) {\n            diffuse =\n              u_diffuseColor *\n              max(dot(L, N), 0.0) *\n              texture2D(u_diffuseMap, v_texcoord);\n          } else {\n            diffuse =\n              u_diffuseColor *\n              max(dot(L, N), 0.0);\n          }\n\n          if (u_useSpecularMap && u_useTextureMapping) {\n            specular = u_specularColor *\n              pow(max(dot(N, H), 0.0), u_shininess) *\n              texture2D(u_specularMap, v_texcoord);\n          } else {\n            specular = u_specularColor *\n              pow(max(dot(N, H), 0.0), u_shininess);\n          }\n\n          float attenuation = 1.0;\n\n          if (u_useEnvironmentMapping) {\n            gl_FragColor = textureCube(u_environmentMap, direction);\n          } else {\n            gl_FragColor = attenuation * (diffuse + specular) + ambient;\n          }\n\n          if (u_useVertexColors) {\n            gl_FragColor = gl_FragColor * v_color;\n          }\n      }\n    ","uniforms":{"ambientColor":["Color",[0,0,0,0.5]],"diffuseColor":["Color",[1,1,1,1]],"specularColor":["Color",[1,1,1,1]],"shininess":1},"type":"PhongMaterial","name":"PhongP"}],"PTopFin":[{"vertexShader":"\n        attribute vec4 position;\n        attribute vec4 color;\n        attribute vec3 normal;\n        attribute vec2 texcoord;\n        uniform bool u_useVertexColors;\n\n        uniform float u_shininess;\n        uniform vec3 u_lightDirection;\n        uniform vec3 u_cameraPosition;\n\n        uniform vec4 u_ambientColor;\n        uniform vec4 u_diffuseColor;\n        uniform vec4 u_specularColor;\n        varying vec4 v_color;\n\n        uniform mat4 u_worldMatrix;\n        uniform mat4 u_viewMatrix;\n\n        uniform sampler2D u_displacementMap;\n        uniform float u_displacementFactor;\n\n        varying vec3 v_lightDirection;\n        varying vec3 v_cameraPosition;\n        varying vec3 v_vertexPosition;\n        varying vec2 v_texcoord;\n        varying vec3 v_normal;\n\n        void main() {\n          gl_Position = u_viewMatrix * u_worldMatrix * position;\n          v_vertexPosition = gl_Position.xyz / gl_Position.w;\n          v_normal = mat3(u_worldMatrix) * normal;\n          v_color = color;\n          v_lightDirection = u_lightDirection;\n          v_cameraPosition = u_cameraPosition;\n          v_texcoord = texcoord;\n        }\n        ","fragmentShader":"\n      precision highp float;\n\n      uniform sampler2D u_normalMap;\n      uniform bool u_useNormalMap;\n      uniform vec4 u_ambientColor;\n      uniform vec4 u_lightColor;\n      uniform sampler2D u_diffuseMap;\n      uniform bool u_useDiffuseMap;\n      uniform vec4 u_diffuseColor;\n      uniform sampler2D u_specularMap;\n      uniform bool u_useSpecularMap;\n      uniform vec4 u_specularColor;\n      uniform float u_shininess;\n      uniform bool u_useVertexColors;\n      uniform bool u_useEnvironmentMapping;\n      uniform bool u_useTextureMapping;\n      uniform samplerCube u_environmentMap;\n\n      varying vec3 v_lightDirection;\n      varying vec3 v_cameraPosition;\n      varying vec3 v_vertexPosition;\n      varying vec2 v_texcoord;\n      varying vec3 v_normal;\n      varying vec4 v_color;\n\n      void main() {\n          vec3 L = -normalize(v_lightDirection - v_vertexPosition);\n          vec3 V = normalize(v_cameraPosition);\n          vec3 H = normalize(L + V);\n          vec3 N;\n          vec4 diffuse;\n          vec4 specular;\n\n          if (u_useNormalMap && u_useTextureMapping) {\n              N = texture2D(u_normalMap, v_texcoord).rgb;\n              N = normalize(N * 2.0 - 1.0);\n          } else {\n              N = normalize(v_normal);\n          }\n\n          vec3 direction = reflect(normalize(v_vertexPosition - v_cameraPosition), N);\n          vec4 ambient = u_ambientColor * u_lightColor * 0.3;\n\n          if (u_useDiffuseMap && u_useTextureMapping) {\n            diffuse =\n              u_diffuseColor *\n              max(dot(L, N), 0.0) *\n              texture2D(u_diffuseMap, v_texcoord);\n          } else {\n            diffuse =\n              u_diffuseColor *\n              max(dot(L, N), 0.0);\n          }\n\n          if (u_useSpecularMap && u_useTextureMapping) {\n            specular = u_specularColor *\n              pow(max(dot(N, H), 0.0), u_shininess) *\n              texture2D(u_specularMap, v_texcoord);\n          } else {\n            specular = u_specularColor *\n              pow(max(dot(N, H), 0.0), u_shininess);\n          }\n\n          float attenuation = 1.0;\n\n          if (u_useEnvironmentMapping) {\n            gl_FragColor = textureCube(u_environmentMap, direction);\n          } else {\n            gl_FragColor = attenuation * (diffuse + specular) + ambient;\n          }\n\n          if (u_useVertexColors) {\n            gl_FragColor = gl_FragColor * v_color;\n          }\n      }\n    ","uniforms":{"ambientColor":["Color",[0,0,0,0.5]],"diffuseColor":["Color",[1,1,1,1]],"specularColor":["Color",[1,1,1,1]],"shininess":1},"type":"PhongMaterial","name":"PhongP"}]}}],"backgroundColor":[1,1,1,1]},"environmentMapping":false,"textureMapping":false,"useNormalMap":true,"useDiffuseMap":true,"useSpecularMap":true,"useDisplacementMap":true,"texture":"brick"}